<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noodles Flow Field - Paper.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.10/dist/tweakpane.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #canvas-container {
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            background: white;
            transition: width 0.3s, height 0.3s;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: white;
            display: block;
            max-width: 100%;
            max-height: 100%;
        }
    </style>
</head>
<body>

<div id="canvas-container">
    <canvas id="canvas" resize="false"></canvas>
</div>

<script>
paper.setup('canvas');
let simplex = new SimplexNoise();

// ============================================================
// FORMAT DEFINITIONS
// ============================================================
const FORMATS = {
    'a4': { w: 595, h: 842 },
    'a3': { w: 842, h: 1190 },
    'square': { w: 800, h: 800 },
    'screen': { w: window.innerWidth, h: window.innerHeight }
};

// ============================================================
// PARAMETERS - Single source of truth
// ============================================================
const params = {
    // Canvas
    format: 'a4',
    margin: 40,
    seed: Math.floor(Math.random() * 10000),

    // Lines
    separation: 6,
    strokeWidth: 2.5,
    maxSteps: 400,

    // Zone system
    zones: {
        enabled: false,
        count: 3,
        transitionWidth: 0.5,  // 0-1, how far zones blend
        placement: 'random',   // 'random', 'corners', 'grid'
        showDebug: false
    },

    // Forces - each has weight (0 = off, 1 = full)
    forces: {
        noise: {
            weight: 1.0,
            scale: 200,
            complexity: 1.5,
            octaves: 1
        },
        circular: {
            weight: 0.0,
            centerX: 0.5,
            centerY: 0.5,
            frequency: 2,
            mode: 'tangent'
        },
        cosine: {
            weight: 0.0,
            scaleX: 100,
            scaleY: 100,
            amplitude: 1.0,
            phase: 0
        },
        diagonal: {
            weight: 0.0,
            angle: 45,
            wave: 0
        }
    }
};

// ============================================================
// SEEDED RANDOM
// ============================================================
function mulberry32(seed) {
    return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

let rng = mulberry32(params.seed);

// ============================================================
// ZONE SYSTEM
// ============================================================
let zones = [];

const FALLOFF = {
    smooth: (dist, radius) => {
        const t = Math.min(1, dist / radius);
        const x = 1 - t;
        return x * x * (3 - 2 * x); // smoothstep
    },
    linear: (dist, radius) => Math.max(0, 1 - dist / radius),
    sharp: (dist, radius) => {
        const t = Math.min(1, dist / radius);
        return 1 - t * t * t * t;
    }
};

function generateZoneAnchors(count, rng) {
    const anchors = [];
    const placement = params.zones.placement;

    if (placement === 'corners') {
        const corners = [
            { x: 0.2, y: 0.2 }, { x: 0.8, y: 0.2 },
            { x: 0.2, y: 0.8 }, { x: 0.8, y: 0.8 },
            { x: 0.5, y: 0.5 }
        ];
        for (let i = 0; i < Math.min(count, corners.length); i++) {
            anchors.push({
                x: corners[i].x + (rng() - 0.5) * 0.1,
                y: corners[i].y + (rng() - 0.5) * 0.1
            });
        }
    } else if (placement === 'grid') {
        const cols = Math.ceil(Math.sqrt(count));
        const rows = Math.ceil(count / cols);
        for (let i = 0; i < count; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            anchors.push({
                x: (col + 0.5) / cols + (rng() - 0.5) * 0.1,
                y: (row + 0.5) / rows + (rng() - 0.5) * 0.1
            });
        }
    } else {
        // Random with rule-of-thirds bias
        const thirds = [0.33, 0.5, 0.67];
        for (let i = 0; i < count; i++) {
            if (rng() < 0.6 && i < 4) {
                // Bias toward thirds intersections
                anchors.push({
                    x: thirds[Math.floor(rng() * 3)] + (rng() - 0.5) * 0.15,
                    y: thirds[Math.floor(rng() * 3)] + (rng() - 0.5) * 0.15
                });
            } else {
                anchors.push({
                    x: 0.1 + rng() * 0.8,
                    y: 0.1 + rng() * 0.8
                });
            }
        }
    }
    return anchors;
}

function generateZoneForces(rng) {
    // Generate random force weights for a zone
    // Ensure clear dominance to avoid turbulent competing forces
    const forceNames = Object.keys(params.forces);
    const weights = {};

    // Shuffle to pick random dominant force
    const shuffled = [...forceNames].sort(() => rng() - 0.5);

    // First force is strongly dominant (0.7-1.0)
    // Others are weak (0-0.2) to avoid competition
    for (let i = 0; i < forceNames.length; i++) {
        const name = shuffled[i];
        if (i === 0) {
            weights[name] = 0.7 + rng() * 0.3; // 0.7-1.0 dominant
        } else if (i === 1 && rng() < 0.3) {
            // 30% chance of a secondary force, but still weaker
            weights[name] = 0.1 + rng() * 0.2; // 0.1-0.3 secondary
        } else {
            weights[name] = rng() * 0.1; // 0-0.1 negligible
        }
    }

    return weights;
}

function generateZones(rng) {
    if (!params.zones.enabled || params.zones.count === 0) return [];

    const anchors = generateZoneAnchors(params.zones.count, rng);
    const generatedZones = [];

    for (const anchor of anchors) {
        generatedZones.push({
            anchor,
            radius: (0.25 + rng() * 0.35) * params.zones.transitionWidth * 2,
            falloff: ['smooth', 'smooth', 'linear'][Math.floor(rng() * 3)],
            forceWeights: generateZoneForces(rng)
        });
    }

    return generatedZones;
}

function getZoneInfluence(point, bounds) {
    if (!params.zones.enabled || zones.length === 0) {
        return null; // Use global params
    }

    const nx = (point.x - bounds.x) / bounds.width;
    const ny = (point.y - bounds.y) / bounds.height;

    const influences = [];
    let totalWeight = 0;

    for (const zone of zones) {
        const dx = nx - zone.anchor.x;
        const dy = ny - zone.anchor.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        const falloffFn = FALLOFF[zone.falloff] || FALLOFF.smooth;
        const weight = falloffFn(dist, zone.radius);

        if (weight > 0.001) {
            influences.push({ zone, weight });
            totalWeight += weight;
        }
    }

    if (totalWeight === 0) return null;

    // Blend force weights from all influencing zones
    const blendedWeights = {};
    for (const name of Object.keys(params.forces)) {
        blendedWeights[name] = 0;
    }

    for (const inf of influences) {
        const normWeight = inf.weight / totalWeight;
        for (const [name, w] of Object.entries(inf.zone.forceWeights)) {
            blendedWeights[name] += w * normWeight;
        }
    }

    return blendedWeights;
}

// ============================================================
// FORCE FUNCTIONS - Each returns an angle in radians
// ============================================================
const forceFunctions = {
    noise: (point, p) => {
        let n = 0;
        let amp = 1;
        let freq = 1;
        for (let o = 0; o < p.octaves; o++) {
            n += amp * simplex.noise2D(
                point.x / p.scale * freq,
                point.y / p.scale * freq
            );
            amp *= 0.5;
            freq *= 2;
        }
        return n * Math.PI * p.complexity;
    },

    circular: (point, p, bounds) => {
        const cx = bounds.x + bounds.width * p.centerX;
        const cy = bounds.y + bounds.height * p.centerY;
        const dx = point.x - cx;
        const dy = point.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const baseAngle = Math.atan2(dy, dx);

        switch (p.mode) {
            case 'tangent':
                return baseAngle + Math.PI / 2 + Math.sin(dist / 50 * p.frequency) * 0.5;
            case 'radial':
                return baseAngle + Math.cos(dist / 30 * p.frequency) * Math.PI;
            case 'spiral':
                return baseAngle + Math.PI / 2 + dist / 100 * p.frequency;
            default:
                return baseAngle + Math.PI / 2;
        }
    },

    cosine: (point, p) => {
        const wave = Math.cos(point.x / p.scaleX + p.phase) *
                     Math.sin(point.y / p.scaleY + p.phase);
        return wave * Math.PI * p.amplitude;
    },

    diagonal: (point, p) => {
        const baseAngle = p.angle * Math.PI / 180;
        if (p.wave === 0) return baseAngle;
        const perpDist = point.x * Math.sin(baseAngle) - point.y * Math.cos(baseAngle);
        return baseAngle + Math.sin(perpDist / 50 * p.wave) * 0.5;
    }
};

// ============================================================
// CORE ENGINE
// ============================================================
let grid = [];
let cols, rows, cellSize, bounds, drawingBounds;

// Store previous angle for continuity when forces cancel out
let lastAngle = 0;

function getAngle(point) {
    // Get zone-based weights or use global weights
    const zoneWeights = getZoneInfluence(point, drawingBounds);

    // Use vector averaging to avoid angle discontinuity issues
    // (averaging -170째 and +170째 as angles gives 0째, but as vectors gives 180째)
    let vx = 0;
    let vy = 0;

    for (const [name, force] of Object.entries(params.forces)) {
        // Use zone weight if available, otherwise use global weight
        const weight = zoneWeights ? zoneWeights[name] : force.weight;

        if (weight > 0 && forceFunctions[name]) {
            const angle = forceFunctions[name](point, force, drawingBounds);
            // Convert to weighted vector
            vx += Math.cos(angle) * weight;
            vy += Math.sin(angle) * weight;
        }
    }

    // Check vector magnitude - if too small, forces are canceling out
    const magnitude = Math.sqrt(vx * vx + vy * vy);
    if (magnitude < 0.01) {
        // Use last known good angle for continuity
        return lastAngle;
    }

    lastAngle = Math.atan2(vy, vx);
    return lastAngle;
}

function resizeCanvas() {
    const canvas = document.getElementById('canvas');
    const container = document.getElementById('canvas-container');

    if (params.format === 'screen') {
        FORMATS.screen.w = window.innerWidth;
        FORMATS.screen.h = window.innerHeight;
        canvas.style.width = '100vw';
        canvas.style.height = '100vh';
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        paper.view.viewSize = new paper.Size(window.innerWidth, window.innerHeight);
        container.style.width = '100%';
        container.style.height = '100%';
        container.style.boxShadow = 'none';
    } else {
        const dim = FORMATS[params.format];
        canvas.width = dim.w;
        canvas.height = dim.h;
        paper.view.viewSize = new paper.Size(dim.w, dim.h);
        canvas.style.width = '';
        canvas.style.height = '';
        container.style.width = 'auto';
        container.style.height = 'auto';
        container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.4)';
    }
}

function setupGrid() {
    bounds = paper.view.bounds;
    drawingBounds = new paper.Rectangle(
        params.margin,
        params.margin,
        bounds.width - (params.margin * 2),
        bounds.height - (params.margin * 2)
    );

    cellSize = params.separation;
    if (bounds.width === 0) return;

    cols = Math.ceil(bounds.width / cellSize);
    rows = Math.ceil(bounds.height / cellSize);
    grid = new Array(cols * rows).fill(null);
}

function isValid(point) {
    if (!drawingBounds.contains(point)) return false;

    const col = Math.floor(point.x / cellSize);
    const row = Math.floor(point.y / cellSize);

    for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            const c = col + i;
            const r = row + j;
            if (c >= 0 && c < cols && r >= 0 && r < rows) {
                const existing = grid[c + r * cols];
                if (existing && point.getDistance(existing) < params.separation) {
                    return false;
                }
            }
        }
    }
    return true;
}

function mark(point) {
    const col = Math.floor(point.x / cellSize);
    const row = Math.floor(point.y / cellSize);
    if (col >= 0 && col < cols && row >= 0 && row < rows) {
        grid[col + row * cols] = point;
    }
}

function createStreamline(startPoint) {
    const points = [];
    let current = startPoint.clone();
    points.push(current);

    const stepSize = params.separation / 2;

    // Forward
    for (let i = 0; i < params.maxSteps; i++) {
        const angle = getAngle(current);
        const vector = new paper.Point({ length: stepSize, angle: angle * 180 / Math.PI });
        const next = current.add(vector);
        if (isValid(next)) {
            points.push(next);
            current = next;
        } else break;
    }

    // Backward
    current = startPoint.clone();
    const backwardPoints = [];
    for (let i = 0; i < params.maxSteps; i++) {
        const angle = getAngle(current);
        const vector = new paper.Point({ length: stepSize, angle: (angle * 180 / Math.PI) + 180 });
        const next = current.add(vector);
        if (isValid(next)) {
            backwardPoints.unshift(next);
            current = next;
        } else break;
    }

    const fullLine = backwardPoints.concat(points);
    if (fullLine.length < 5) return false;

    const path = new paper.Path({
        strokeColor: '#1a1a1a',
        strokeWidth: params.strokeWidth,
        strokeCap: 'round',
        strokeJoin: 'round'
    });

    for (const p of fullLine) {
        path.add(p);
        mark(p);
    }

    path.smooth();
    return true;
}

function drawZoneDebug() {
    if (!params.zones.showDebug || !params.zones.enabled) return;

    for (const zone of zones) {
        const cx = drawingBounds.x + zone.anchor.x * drawingBounds.width;
        const cy = drawingBounds.y + zone.anchor.y * drawingBounds.height;
        const r = zone.radius * Math.min(drawingBounds.width, drawingBounds.height);

        // Draw zone circle
        const circle = new paper.Path.Circle({
            center: [cx, cy],
            radius: r,
            strokeColor: 'rgba(255, 0, 0, 0.3)',
            strokeWidth: 1,
            dashArray: [4, 4]
        });

        // Draw anchor point
        new paper.Path.Circle({
            center: [cx, cy],
            radius: 4,
            fillColor: 'rgba(255, 0, 0, 0.5)'
        });

        // Label dominant force
        const dominant = Object.entries(zone.forceWeights)
            .sort((a, b) => b[1] - a[1])[0];
        new paper.PointText({
            point: [cx, cy - 10],
            content: `${dominant[0]}: ${dominant[1].toFixed(1)}`,
            fontSize: 10,
            fillColor: 'rgba(255, 0, 0, 0.7)',
            justification: 'center'
        });
    }
}

function generate() {
    // Reset RNG and noise with current seed
    rng = mulberry32(params.seed);
    simplex = new SimplexNoise(rng);

    // Generate zones
    zones = generateZones(rng);

    resizeCanvas();
    paper.project.activeLayer.removeChildren();

    new paper.Path.Rectangle({
        rectangle: paper.view.bounds,
        fillColor: 'white'
    }).sendToBack();

    setupGrid();

    const maxAttempts = 6000;
    for (let i = 0; i < maxAttempts; i++) {
        const x = drawingBounds.x + rng() * drawingBounds.width;
        const y = drawingBounds.y + rng() * drawingBounds.height;
        const start = new paper.Point(x, y);
        if (isValid(start)) {
            createStreamline(start);
        }
    }

    // Draw debug overlay
    drawZoneDebug();

    paper.view.draw();
}

function randomizeSeed() {
    params.seed = Math.floor(Math.random() * 10000);
    pane.refresh();
    generate();
}

// ============================================================
// EXPORT
// ============================================================
function downloadSVG() {
    const svg = paper.project.exportSVG({ asString: true });
    const url = "data:image/svg+xml;utf8," + encodeURIComponent(svg);
    const link = document.createElement("a");
    link.download = `noodles_${params.format}_${Date.now()}.svg`;
    link.href = url;
    link.click();
}

function downloadPNG() {
    const canvas = document.getElementById('canvas');
    const link = document.createElement('a');
    link.download = `noodles_${Date.now()}.png`;
    link.href = canvas.toDataURL();
    link.click();
}

// ============================================================
// TWEAKPANE GUI
// ============================================================
const pane = new Tweakpane.Pane({ title: 'Noodles Flow Field' });

// Canvas folder
const canvasFolder = pane.addFolder({ title: 'Canvas' });
canvasFolder.addInput(params, 'format', {
    options: { 'A4': 'a4', 'A3': 'a3', 'Square': 'square', 'Screen': 'screen' }
}).on('change', generate);
canvasFolder.addInput(params, 'margin', { min: 0, max: 100, step: 5 });
canvasFolder.addInput(params, 'seed', { min: 0, max: 99999, step: 1 });
canvasFolder.addButton({ title: 'New Seed' }).on('click', randomizeSeed);

// Lines folder
const linesFolder = pane.addFolder({ title: 'Lines' });
linesFolder.addInput(params, 'separation', { min: 2, max: 20, step: 1, label: 'density' });
linesFolder.addInput(params, 'strokeWidth', { min: 0.5, max: 8, step: 0.5, label: 'stroke' });
linesFolder.addInput(params, 'maxSteps', { min: 50, max: 800, step: 50, label: 'max length' });

// Zones folder
const zonesFolder = pane.addFolder({ title: 'Zones', expanded: true });
zonesFolder.addInput(params.zones, 'enabled').on('change', generate);
zonesFolder.addInput(params.zones, 'count', { min: 1, max: 6, step: 1 }).on('change', generate);
zonesFolder.addInput(params.zones, 'transitionWidth', { min: 0.2, max: 1.5, step: 0.1, label: 'blend' }).on('change', generate);
zonesFolder.addInput(params.zones, 'placement', {
    options: { 'Random': 'random', 'Corners': 'corners', 'Grid': 'grid' }
}).on('change', generate);
zonesFolder.addInput(params.zones, 'showDebug', { label: 'debug' }).on('change', generate);

// Forces (global defaults, overridden by zones when enabled)
const forcesFolder = pane.addFolder({ title: 'Forces (global)', expanded: false });

const noiseFolder = forcesFolder.addFolder({ title: 'Noise' });
noiseFolder.addInput(params.forces.noise, 'weight', { min: 0, max: 1, step: 0.1 });
noiseFolder.addInput(params.forces.noise, 'scale', { min: 50, max: 500, step: 10 });
noiseFolder.addInput(params.forces.noise, 'complexity', { min: 0.5, max: 3, step: 0.1 });
noiseFolder.addInput(params.forces.noise, 'octaves', { min: 1, max: 4, step: 1 });

const circularFolder = forcesFolder.addFolder({ title: 'Circular' });
circularFolder.addInput(params.forces.circular, 'weight', { min: 0, max: 1, step: 0.1 });
circularFolder.addInput(params.forces.circular, 'mode', {
    options: { 'Tangent': 'tangent', 'Radial': 'radial', 'Spiral': 'spiral' }
});
circularFolder.addInput(params.forces.circular, 'centerX', { min: 0, max: 1, step: 0.05, label: 'center X' });
circularFolder.addInput(params.forces.circular, 'centerY', { min: 0, max: 1, step: 0.05, label: 'center Y' });
circularFolder.addInput(params.forces.circular, 'frequency', { min: 0.5, max: 10, step: 0.5 });

const cosineFolder = forcesFolder.addFolder({ title: 'Cosine Waves' });
cosineFolder.addInput(params.forces.cosine, 'weight', { min: 0, max: 1, step: 0.1 });
cosineFolder.addInput(params.forces.cosine, 'scaleX', { min: 20, max: 300, step: 10, label: 'scale X' });
cosineFolder.addInput(params.forces.cosine, 'scaleY', { min: 20, max: 300, step: 10, label: 'scale Y' });
cosineFolder.addInput(params.forces.cosine, 'amplitude', { min: 0.1, max: 2, step: 0.1 });
cosineFolder.addInput(params.forces.cosine, 'phase', { min: 0, max: Math.PI * 2, step: 0.1 });

const diagonalFolder = forcesFolder.addFolder({ title: 'Diagonal' });
diagonalFolder.addInput(params.forces.diagonal, 'weight', { min: 0, max: 1, step: 0.1 });
diagonalFolder.addInput(params.forces.diagonal, 'angle', { min: 0, max: 360, step: 5 });
diagonalFolder.addInput(params.forces.diagonal, 'wave', { min: 0, max: 3, step: 0.1 });

// Actions
pane.addButton({ title: 'Regenerate' }).on('click', generate);

const exportFolder = pane.addFolder({ title: 'Export', expanded: false });
exportFolder.addButton({ title: 'Download SVG' }).on('click', downloadSVG);
exportFolder.addButton({ title: 'Download PNG' }).on('click', downloadPNG);

// ============================================================
// INIT
// ============================================================
window.addEventListener('resize', () => {
    if (params.format === 'screen') generate();
});

setTimeout(generate, 100);
</script>
</body>
</html>
